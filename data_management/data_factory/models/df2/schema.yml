version: 2

models:
  - name: mesure_last
    description: |
        Pour chaque {indic_id, metric_type, metric_date, zone_id}, on retourne la valeur la plus récente. Règles:

        - Si 2 valeurs pour le meme {indic_id, metric_type, metric_date, zone_id}, on retourne celle avec la date d'import la plus récente
        - Si 2 valeurs dans le même mois, à des jours différents, on garde **les deux**
        - Transformation de `'null'` et `''` vers un `NULL`
  - name: agg_dept
    description: |
        Sélection des valeurs et calculs des aggrégation pour le niveau DEPT en fonction des paramètres. Règles:

        - on ne garde les valeurs saisies, que si elles comportent `user_input` dans leur paramètrage (`vi_dept_from`, `va_dept_from`, `vc_dept_from`)
        - aucun calcul d'aggrégation n'est fait à ce niveau car le DEPT est la maille la plus basse
  - name: zone_parent
    description: |
        Pour chaque zone, on indique ses zones parents.

        Par exemple, pour les DEPT, on a leur REG de rattachement. Cette table est utile pour les aggrégations géographiques.  
  - name: zone_parent_parent
    description: |
        Pour chaque zone, on indique ses zones parents sur 2 niveaux.

        Par exemple, pour les DEPT, on a leur REG de rattachement et leur NAT de rattachement. Cette table est utile pour les aggrégations géographiques.
  - name: agg_reg
    description: |
        Sélection des valeurs et calculs des aggrégation pour le niveau REG en fonction des paramètres. Règles:

        - on ne garde les valeurs saisies, que si elles comportent `user_input` dans leur paramètrage (`vi_reg_from`, `va_reg_from`, `vc_reg_from`)
        - pour l'aggrégation, on ne prend en compte que les opérations `sum` et `avg`
        - les aggrégations se font de DEPT vers REG, lorsque l'on a `DEPT` dans `vi_reg_from`, `va_reg_from` ou `vc_reg_from`
        - les aggrégations se font par `metric_date` exact (pas arrondi au mois). Ex: si on a `{D75,2023-08-31,10}` et `{D91,2023-08-15,25}`, on aura `{R11,2023-08-31,10}` et `{R11,2023-08-15,25}`
        - si l'opération n'est pas supportée, on aura la valeur `-1.212121` qui sera retournée comme résultat de l'aggrégation
  - name: agg_nat
    description: |
        Sélection des valeurs et calculs des aggrégation pour le niveau NAT en fonction des paramètres. Règles:

        - on ne garde les valeurs saisies, que si elles comportent `user_input` dans leur paramètrage (`vi_nat_from`, `va_nat_from`, `vc_nat_from`)
        - pour l'aggrégation, on ne prend en compte que les opérations `sum` et `avg`
        - les aggrégations se font de REG vers NAT, lorsque l'on a `REG` dans `vi_nat_from`, `va_nat_from` ou `vc_nat_from`
        - on se base sur la table d'aggrégation de DEPT vers REG (`agg_reg`) pour déterminer les valeurs au NAT. En effet, il est possible que des valeurs DEPT soient nécessaire pour le calcul des valeurs au REG, **et** que ces valeurs calculées au REG soient nécessaires pour le calcul des valeurs NAT. Il ne faut donc pas repartir de la table des valeurs importées, mais bien de la table de résultat de l'aggrégation REG.
        - les aggrégations se font par `metric_date` exact (pas arrondi au mois). Ex: si on a `{R01,2023-08-31,10}` et `{R02,2023-08-15,25}`, on aura `{FRANCE,2023-08-31,10}` et `{FRANCE,2023-08-15,25}`
        - si l'opération n'est pas supportée, on aura la valeur `-1.212121` qui sera retournée comme résultat de l'aggrégation
  - name: agg_all
    description: "Combinaision des tables d'aggrégation aux trois mailles (DEPT, REG, NAT)"
  - name: pivot_mesures
    description: "La table des mesures aggrégées (`agg_all`) est pivotée."
  - name: get_vca
    description: |
        Réalise les calculs pour déterminer la *VCA* (ie *Valeur Cible annuelle*). Règles:

        - Pour chaque [indicateur, zone, année] il s'agit de la VC ayant la `metric_date` la plus tardive dans l'année.
  - name: get_vcg
    description: |
        Réalise les calculs pour déterminer la *VCG* (ie *Valeur Cible globale*). Règles:

        - Pour chaque [indicateur, zone] il s'agit de la VC ayant la `metric_date` la plus tardive saisie
        - **Attention**, il existe une **date maximum** dans le projet dbt, et qui assure qu'aucune VCG ne sera plus tardive que celle-ci. Sa valeur est **{{ var('vcg_max_date') }}**
  - name: get_vig
    description: |
        Réalise les calculs pour déterminer la *VIG* (ie *Valeur Initiale globale*). Règles:

        - Pour chaque [indicateur, zone] il s'agit de la VI ayant la `metric_date` la plus lointaine dans le passé.
        - Si aucune VI n'est détectée, on prend la première VA. Cette première VA doit également satisfaire le critère suivant sur la *date_minimale*
        - **Attention**, il existe une **date minimale** dans le projet dbt, et qui assure qu'aucune VIG ne sera antérieure celle-ci. Sa valeur est **{{ var('vig_min_date') }}**
  - name: compute_vaca
    description: |
        Calcule les VACA (*Valeur Actuelle comparable annuelle*) pour chaque mesure. Cette valeur est celle qui sera comparée à la VC pour le calcul du TA. Règles:

        - Avant d'effectuer le calcul de la VACA, on peut **décumuler les valeurs de VA** depuis le début de l'année `from_year_start` ou depuis une date arbitraire `X` avec `from_custom_date::X`
        - Le calcul de la VACA se fait avec:
          - les opérations `sum`, `moy` ou `current_value` pour la *somme*, la *moyenne* ou utiliser simplement la valeur actuelle
          - depuis un nombre de mois donné `from_previous_month::X`, avec `X` dans `{3,6,12,48}` mois
          - depuis le début de l'année `from_year_start`
          - depuis le une date arbitraire  `X` avec `from_custom_date::X`
  - name: compute_vacg
    description: |
        Calcule les VACG (*Valeur Actuelle comparable globale*) pour chaque mesure. Cette valeur est celle qui sera comparée à la VC pour le calcul du TA. Règles:

        - Les règles sont identiques à celles de `compute_vacg` mais en prenant en compte les paramètres globaux et non annuels
  - name: merge_computed_values
    description: Jointure des VACA, VACG, VCA, VCG, VIG dans une table unqie avant de calculer les TA.
