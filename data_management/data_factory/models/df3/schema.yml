version: 2

models:
  - name: mesure_last
    description: |
        Pour chaque {indic_id, metric_type, metric_date, zone_id}, on retourne la valeur la plus récente. Règles:

        - On ne garde que les mesures sur les **zones applicables** (voir `view_meta_indicateur` colonne `zg_applicable` et ref `int_indicateurs_zones_applicables` pour les détails)
        - Si 2 valeurs pour le meme {indic_id, metric_type, metric_date, zone_id}, on retourne celle avec la date d'import la plus récente. On dit que c'est la valeur **valable**. Ex: `[{date_import1, 12-dec-25, va, 10}, {date_import2, 12-dec-25, va, 15}] => [{date_import2, 12-dec-25, va, 15}]`
        - Si 2 valeurs dans le même mois, à des jours différents, on garde **les deux**. Ces deux valeurs sont des *valeurs valables*.
        - Transformation de `'null'` et `''` vers un `NULL`

        *Note:* Avant de charger la table des données importées (`source('import_from_files', 'mesure_indicateur')`), on remplace les valeurs `metric_date='2023-06-31'` par `metric_date='2023-06-30'`. C'est la table intermédiaire `fix_mesure_indicateur_06_31`.
  - name: mesure_last_null_erase
    description: |
        On modifie la table précédente `mesure_last`. Si un `NULL` existe, on enlève toutes les autres valeurs du mois. Règles:

        - Si un `NULL` est *valable*, on supprime toutes les autres valeurs *valables* de ce mois. Ex: `[{12-dec-25, va, 10}, {17-dec-25, va, 15}, {23-dec-25, va, NULL}] => [{23-dec-25, va, NULL}]`
  - name: mesure_last_null_erase_keep_lastvalmonth
    description: |
        On modifie la table précédente `mesure_last_null_erase`. Règles:

        - 1. Si plusieurs valeurs sont valables pour un même mois, on garde la valeur importée le plus récemment et on arrondit sa date au premier jour du mois.
        - **Cas particulier:** si on ne peut pas déterminer la valeur *importée le plus récemment* (règle précédente inefficace), càd que 2 valeurs sont importées au même mois lors du même import, on sélectionne la valeur avec la `metric_date` la plus tardive dans le mois
        - **Cas particulier:** si on ne peut pas déterminer la *`metric_date` la plus tardive* (règle précédente inefficace), càd que 2 valeurs sont importées lorsque 2 valeurs sont importées au même mois lors du même import, **avec la `metric_date`** -> C'est **impossible**, car le schema validata d'import des données empêche cela ([cf schema validata](https://github.com/DITP-pilotage/pilote-2/blob/43832f300e3b1ef97a35cc197388c23b49928333/public/schema/sans-contraintes.json#L114-L119))

        *Bug corrigé [PIL-88](https://data-ditp.atlassian.net/browse/PIL-88):* Ce bug est survenu car avant ce correctif, pour déterminer la "valeur importée le plus récemment" (dans *1.*), on triait les *dates d'import* et non les *timestamp complets*. Donc si deux valeurs étaient importées le même jour, elles apparaissaient toutes deux au *rang=1* donc impossible de les départager.
  - name: agg_all_replicate
    description: |
        [en dev] Ces mesures sont répliquées depuis la maille supérieure spécifiée *(PIL-246)*. Règles:

        - les données répliquées sont `df3.agg_all`. En effet, cette table contient toutes les valeurs aggrégées à toutes les mailles.
        - On fait également ici l'union avec `df3.agg_all`. 
        - Les données **saisies** et **aggrégées** sont répliquées. Par exemple, si on veut répliquer le NAT->DEPT et que la valeur NAT provient d'une aggrégation REG->NAT, çàd aucune donnée NAT n'a été saisie par l'utilisateur mais cette valeur provient d'un calcul d'aggrégation, cela va bien fonctionner.
        - [en dev] Réplication de REG -> DEPT uniquement
  - name: agg_dept
    description: |
        Sélection des valeurs et calculs des aggrégation pour le niveau DEPT en fonction des paramètres. Règles:

        - on ne garde les valeurs saisies, que si elles comportent `user_input` dans leur paramètrage (`vi_dept_from`, `va_dept_from`, `vc_dept_from`)
        - aucun calcul d'aggrégation n'est fait à ce niveau car le DEPT est la maille la plus basse
  - name: zone_parent
    description: |
        Pour chaque zone, on indique ses zones parents.

        Par exemple, pour les DEPT, on a leur REG de rattachement. Cette table est utile pour les aggrégations géographiques.  
  - name: zone_parent_parent
    description: |
        Pour chaque zone, on indique ses zones parents sur 2 niveaux.

        Par exemple, pour les DEPT, on a leur REG de rattachement et leur NAT de rattachement. Cette table est utile pour les aggrégations géographiques.
  - name: agg_reg
    description: |
        Sélection des valeurs et calculs des aggrégation pour le niveau REG en fonction des paramètres. Règles:

        - on ne garde les valeurs saisies, que si elles comportent `user_input` dans leur paramètrage (`vi_reg_from`, `va_reg_from`, `vc_reg_from`)
        - pour l'aggrégation, on ne prend en compte que les opérations `sum` et `avg`
        - les aggrégations se font de DEPT vers REG, lorsque l'on a `DEPT` dans `vi_reg_from`, `va_reg_from` ou `vc_reg_from`
        - les aggrégations se font par `metric_date` exact (pas arrondi au mois). Ex: si on a `{D75,2023-08-31,10}` et `{D91,2023-08-15,25}`, on aura `{R11,2023-08-31,10}` et `{R11,2023-08-15,25}`
        - si l'opération n'est pas supportée, on aura la valeur `-1.212121` qui sera retournée comme résultat de l'aggrégation
  - name: agg_nat
    description: |
        Sélection des valeurs et calculs des aggrégation pour le niveau NAT en fonction des paramètres. Règles:

        - on ne garde les valeurs saisies, que si elles comportent `user_input` dans leur paramètrage (`vi_nat_from`, `va_nat_from`, `vc_nat_from`)
        - pour l'aggrégation, on ne prend en compte que les opérations `sum` et `avg`
        - les aggrégations se font de REG vers NAT, lorsque l'on a `REG` dans `vi_nat_from`, `va_nat_from` ou `vc_nat_from`
        - on se base sur la table d'aggrégation de DEPT vers REG (`agg_reg`) pour déterminer les valeurs au NAT. En effet, il est possible que des valeurs DEPT soient nécessaire pour le calcul des valeurs au REG, **et** que ces valeurs calculées au REG soient nécessaires pour le calcul des valeurs NAT. Il ne faut donc pas repartir de la table des valeurs importées, mais bien de la table de résultat de l'aggrégation REG.
        - les aggrégations se font par `metric_date` exact (pas arrondi au mois). Ex: si on a `{R01,2023-08-31,10}` et `{R02,2023-08-15,25}`, on aura `{FRANCE,2023-08-31,10}` et `{FRANCE,2023-08-15,25}`
        - si l'opération n'est pas supportée, on aura la valeur `-1.212121` qui sera retournée comme résultat de l'aggrégation
  - name: agg_nat_rule544
    description: |
        Application de la *règle 544* sur les **VC et VI NAT**. Règles:

        - Si la VC NAT est normalement cumulée (is `vc_nat_from<>user_input`)
        - Si le calcul du cumul retourne `NULL`
        - Alors, **on retourne la valeur saisie *illégalement* au national**. En théorie, cette valeur devrait être ignorée, mais dans cette règle, on l'utilise pour combler le vide.
        - *Exemple:* une VC 2026 est indiquée au NAT mais pas encore territorialisée: on va l'afficher en attendant la territorialisation. Une fois que les VC DEPT seront renseignées, c'est bien la somme des VC DEPT qui va s'afficher en tant que VC 26. Même logique pour la VI.
  - name: agg_all
    description: "Combinaision des tables d'aggrégation aux trois mailles (DEPT, REG, NAT)"
  - name: pivot_mesures
    description: "La table des mesures aggrégées (`agg_all`) est pivotée."
  - name: get_vca
    description: |
        Réalise les calculs pour déterminer la *VCA* (ie *Valeur Cible annuelle*). Règles:

        - Pour chaque [indicateur, zone, année] il s'agit de la VC ayant la `metric_date` la plus tardive dans l'année.
  - name: get_last_vaca
    description: "Pour chaque {indic_id, zone_id}, retourne la ligne avec la VACA la plus récente."
    columns:
      - name: date_valeur_actuelle
        description: "Date de la dernière VA disponible."
  - name: get_vcg
    description: |
        Réalise les calculs pour déterminer la *VCG* (ie *Valeur Cible globale*). Règles:

        - Pour chaque [indicateur, zone] il s'agit de la VC ayant la `metric_date` la plus tardive saisie
        - **Attention**, il existe une **date maximum** dans le projet dbt, et qui assure qu'aucune VCG ne sera plus tardive que celle-ci. Sa valeur est **{{ var('vcg_max_date') }}**
  - name: get_vig
    description: |
        Réalise les calculs pour déterminer la *VIG* (ie *Valeur Initiale globale*). Règles:

        - **Attention**, il existe une **date minimale** dans le projet dbt, et qui assure qu'aucune VIG ne sera antérieure celle-ci. Sa valeur est **{{ var('vig_min_date') }}**

        Règles **supprimées**:
        - [DELETED] Si aucune VI n'est détectée, on prend la première VA. Cette première VA doit également satisfaire le critère suivant sur la *date_minimale* (cf `commit/a864d5eb18acdb478488a5aded4cb5c0ff942266`)
        - Pour chaque [indicateur, zone] il s'agit de la VI importée le plus récemment. Si deux VI importée dans le même import, on sélectionne celle avec la `metric_date` la plus lointaine dans le passé. Si toujours plusieurs VI candidates, **on sélectionne au hasard** un de ces dates. On fait cela car aucun moyen de les départager autrement.
  - name: compute_vaca
    description: |
        Calcule les VACA (*Valeur Actuelle comparable annuelle*) pour chaque mesure. Cette valeur est celle qui sera comparée à la VC pour le calcul du TA. Règles:

        - Avant d'effectuer le calcul de la VACA, on peut **décumuler les valeurs de VA** depuis le début de l'année `from_year_start` ou depuis une date arbitraire `X` avec `from_custom_date::X`
        - Le calcul de la VACA se fait avec:
          - les opérations `sum`, `moy` ou `current_value` pour la *somme*, la *moyenne* ou utiliser simplement la valeur actuelle
          - depuis un nombre de mois donné `from_previous_month::X`, avec `X` dans `{3,6,12,48}` mois
          - depuis le début de l'année `from_year_start`
          - depuis le une date arbitraire  `X` avec `from_custom_date::X`
  - name: compute_vacp
    description: |
        Récupère les VACP (*Valeur Actuelle comparable proposée*) depuis la table proposition_valeur_actuelle. Cette valeur est celle qui sera comparée à la VC pour le calcul des TA proposés.
        Pour une date de valeur actuelle plusieurs propositions peuvent avoir été faites. On prend uniquement la dernière, c'est à dire celle avec la date de proposition la plus récente.
  - name: compute_vacg
    description: |
        Calcule les VACG (*Valeur Actuelle comparable globale*) pour chaque mesure. Cette valeur est celle qui sera comparée à la VC pour le calcul du TA. Règles:

        - Les règles sont identiques à celles de `compute_vacg` mais en prenant en compte les paramètres globaux et non annuels
  - name: merge_computed_values
    columns:
      - name: vca_courant
        description: Valeur Cible Annuelle (VCA) **courante**. C'est la VC annuelle dont l'année correspond à **l'année de la VA**
      - name: vca_courant_date
        description: "Date de la **VCA courante**"
      - name: vca_adate
        description: Valeur Cible Annuelle (VCA) **à date**. C'est la VC annuelle dont l'année correspond à **l'année en cours**
      - name: vca_adate_date
        description: "Date de la **VCA à date**"
    description: Jointure des VACA, VACG, VCA, VCG, VIG dans une table unqie avant de calculer les TA.
  - name: compute_ta_indic
    description: |
        Calcule les *TAA* et *TAG* (*Taux d'avancement annuels et globaux*) indicateur pour chaque mesure. Règles:

        - Les formules utilisées sont `(vacg-vig)/(vcg-vig)` pour le TAG et `100*(vaca-vig)/(vca-vig)` pour le TAA
        - Si `vig=vca` alors le TAA vaut `NULL`
        - Si `vig=vcg` alors le TAG vaut `NULL`
        - Les TA sont paramétrés pour renvoyer **{{ var('ta_decimales') }} décimales** (paramètres global dbt `ta_decimales`)
        - *Règle 620:* La **VCA** (VC annuelle) est la **VC de l'année courante** et non pas la VC de l'année de la dernière VA. Exemple: Si VC22 est la dernière dispo, alors la VCA sera VC23 et non pas VC22 car on est en 2023.
        - Ajout de règles de calcul du TA indicateur (depuis ce [pad](https://pad.numerique.gouv.fr/nLWF47SnTASKbBKrTFebBQ) pour l'ensemble des règles). Règles en vigueur ici:
          - *Hausse* si `vi >= vc` et `va >= vc` alors `TA = 100%`
          - *Hausse* si `vi >= vc` et `va < vc` alors `TA = 0%`
          - *Hausse* sinon `TA = (va - vi) / (vc - vi)`
          - *Baisse* si `vi <= vc` et `va <= vc` alors `TA = 100%`
          - *Baisse* si `vi <= vc` et `va > vc` alors `TA = 0%`
          - *Baisse* sinon `TA = (va - vi) / (vc - vi)` columns: todo doc
    columns:
      - name: taa_courant
        description: |
          (Ex colonne `taa`) Il s'agit du Taux d'Avancement Annuel (TAA) **courant** de l'indicateur à cette date. 
          
          La VC prise en compte pour ce calcul est la `vca_courant`. 

          *Exemple d'utilisation:* Utile pour calculer la TAA actuellement. Si on est en sept-2024 et la dernière VA est de aou-24, on utilise ce TAA (TAA *courant*). De même, si l'on est en jan-2024 et la dernière VA est de déc-23, on utilise également cela.
      - name: taa_adate
        description: |
          Il s'agit du Taux d'Avancement Annuel (TAA) **courant** de l'indicateur à cette date. 
          
          La VC prise en compte pour ce calcul est la `vca_courant`. 

          *Exemple d'utilisation:* Utile lorsque l'on veut mettre à jour le calcul de TA retrospectivement. Par exemple, nous sommes en 2024, et une VA de déc-2023 est mise à jour. Pour connaitre le TAA tel qu'il aurait été en déc-23, il faut regarder ce TAA (TAA *à date*).
      - name: tag
        description: Taux d'Avancement Global (TAG). Indique l'avancement sur la période compète, utilise la VCG (déterminée dans `get_vcg`).
  - name: df3_indicateur
    description: |
      Table des indicateurs construite par la datafactory dbt. Version reconstruite de zero. Règles:

      - La liste des **indicateurs** provient de ref('metadata_indicateurs') 
      - La liste des **zones** provient de `public.territoire`. Donc si l'on veut renvoyer des données pour d'autres zones (académies, façades maritimes, monde, ...), il faut leur créer un territoire correspondant.
      - *redmine::621*: on récupère les `vig,vca,vcg` des tables `get_vig,get_vca,get_vcg` et non pas de `compute_ta_indic` (comme c'était le cas précédemment). En effet, sinon ces valeurs ne remontaient pas lorsque pas de VA.
      - On retourne les **VACA** et non plus les **VA**
    config:
      docs:
        node_color: "#cd7f32"
      schema: public
      tags: ["df3"]
  - name: get_n_indic_in_ta_expected
    description: |
      Pour chaque couple {chantier, zone}, indique **le nombre d'indicateurs ayant une pondération réelle > 0**. Règles:

      - on se base sur la table `int_ponderation_reelle` pour déterminer si un indicateur est effectivement pondéré
    columns:
      - name: n_indic_in_ta_expected
        description: "Nombre de TA indicateurs attendus dans le chantier pour calculer le TA chantier"
  - name: compute_ta_ch
    description: |
      Pour chaque zone et chaque chantier, donne le **TA** en vigueur actuellement et le **TA précédent**. Règles:

      - on se base sur la table `compute_ta_indic`
      - si un TA indicateur qui est pris en compte de la pondération du TA chantier vaut `NULL`, alors le TA chantier vaudra `NULL`  (*PIL-106*)
      - pour le calcul du *TA actuel*: on utilise la *valeur la plus récente de l'indicateur*, peu importe sa date. Ex: on est en 11-23, on pourra utiliser des données de *11-23* ou antérieures.
      - pour le calcul du *TA précédent*: on utilise la *valeur la plus récente **mais antérieure au mois actuel** de l'indicateur*, peu importe sa date. Ex: on est en 11-23, on ne pourra utiliser que des données de *10-23* ou antérieures.
      - le *TA chantier* est la somme des TA pondérés de chaque indicateur du chantier **DONT la pondération est > 0** (`redmine::721`). On fait cela car si un TA pondéré d'indicateur de valeur `NULL` était pris en compte dans le calcul du TA chantier, le **résultat vaudrait toujours `NULL`**. Or si un indicateur est pondéré à 0, ce ne doit pas être un problème d'avoir un TA qui vaut `NULL`.
      - on compte le nombre de TA indicateurs pris en compte dans le calcul du TA chantier intermédiaire (`taa_courant_ch_int` et `ta_ch_int`) pour chaque {chantier-zone}. Si ce nombre n'est pas celui attendu (`n_indic_in_ta != n_indic_in_ta_expected`), alors **les deux TA chantiers sont mis à `NULL`**: `taa_courant_ch` et `tag_ch`. Sinon, on conserve bien les valeurs des calculs intermédiaires. (*PIL-227*)
    columns:
      - name: tag_ch
        description: "**Principal**: TA chantier *global*. C'est cette valeur qui est remontée comme TA du chantier"
      - name: taa_courant_ch
        description: "TA chantier *annuel* courant"
      - name: valid_on
        description: "Prend les valeurs `[prev_month, today]` pour indiquer s'il s'agit du TA actuel ou du mois précédent."
      - name: date_ta
        description: "Il s'agit de la date du TA chantier. C'est la date la plus récente de mise à jour d'un indicateur pris en compte dans le TA du chantier."
  - name: df3_chantier
    description: |
      Table des chantiers construite par la datafactory dbt. Version reconstruite de zero. Règles:

      - certaines tables sont directement reprises du travail des prestataires: `synthese_triee_par_date`,`chantier_est_barometre`,`indicateurs_zones`,`indicateurs_zones_applicables`,`chantiers_zones_applicables`,
      - un chantier C est applicable sur une zone Z si *au moins un indicateur* du chantier C est applicable sur la zone Z
    config:
      docs:
        node_color: "#cd7f32"
      schema: public
      tags: ["df3"]
  - name: get_max_date_vaca_ch
    description: |
      Pour chaque {chantier, zone}, on retourne 2 dates qui indiquent les dates maximales que l'on peut prendre en compte pour les VACA indicateur pour calculer le `taux_avancement_ch` et surtout le `taux_avancement_precedent_ch`.
      Cela permet d'avoir 2 TA de chantier distincts, pour les comparer et en déduire une évolution du TA chantier.

      En effet, pour calculer le TA du chantier actuellement, on prend les dernières valeurs dispos des indicateurs. En revanche, pour calculer le taux d'avancement précédent, ce n'est pas trivial car les indicateurs peuvent avoir des dates de màj différentes. Pour déterminer la date max pour calculer le TA précédent, il faut sélectionner la **date max de màj d'un indicateur du chantier qui est inférieure à la date la plus récente**. C'est le but de ce modèle.
    columns:
      - name: max_date_taa_courant_today
        description: la date max que l'on peut prendre en compte pour calculer le taa_courant du chantier aujourd'hui
      - name: max_date_taa_courant_previous
        description: la date max que l'on peut prendre en compte pour calculer le taa_courant du chantier précédemment
  - name: get_date_pro_maj_indic
    description: |
      Pour chaque {indic_id, maille}, on va calculer si le TA est à jour par rapport à la périodicité déclarée de mise à jour des données.
    columns:
      - name: last_va_date
        description: "Date de la VA la plus récente pour toutes les zones de cette maille pour cet indicateur."
      - name: prochaine_date_maj
        description: "Date de màj théorique des VA pour cet indicateur d'après la périodicité déclarée. La date est **le dernier jour du mois**."
      - name: prochaine_date_maj_jours
        description: "Nombre de jours avant la prochaine date de màj théorique. Négatif si la donnée n'est pas à jour, çàd que la date de prochaine màj théorique est dans le passé."
      - name: prochaine_date_va
        description: "Prochaine date de VA qui sera théoriquement disponible"
      - name: est_a_jour
        description: "Indique si la donnée est à jour selon les données temporelles théoriques déclarées."
    
