version: 2

models:
  - name: mesure_last
    description: |
        Pour chaque {indic_id, metric_type, metric_date, zone_id}, on retourne la valeur la plus récente. Règles:

        - Si 2 valeurs pour le meme {indic_id, metric_type, metric_date, zone_id}, on retourne celle avec la date d'import la plus récente. On dit que c'est la valeur **valable**. Ex: `[{date_import1, 12-dec-25, va, 10}, {date_import2, 12-dec-25, va, 15}] => [{date_import2, 12-dec-25, va, 15}]`
        - Si 2 valeurs dans le même mois, à des jours différents, on garde **les deux**. Ces deux valeurs sont des *valeurs valables*.
        - Transformation de `'null'` et `''` vers un `NULL`

        *Note:* Avant de charger la table des données importées (`source('import_from_files', 'mesure_indicateur')`), on remplace les valeurs `metric_date='2023-06-31'` par `metric_date='2023-06-30'`. C'est la table intermédiaire `fix_mesure_indicateur_06_31`.
  - name: mesure_last_null_erase
    description: |
        On modifie la table précédente `mesure_last`. Si un `NULL` existe, on enlève toutes les autres valeurs du mois. Règles:

        - Si un `NULL` est *valable*, on supprime toutes les autres valeurs *valables* de ce mois. Ex: `[{12-dec-25, va, 10}, {17-dec-25, va, 15}, {23-dec-25, va, NULL}] => [{23-dec-25, va, NULL}]`
  - name: mesure_last_null_erase_keep_lastvalmonth
    description: |
        On modifie la table précédente `mesure_last_null_erase`. Règles:

        - Si plusieurs valeurs sont valables pour un même mois, on garde la dernière ainsi que sa date. Ex: `[{12-dec-25, va, 10}, {17-dec-25, va, 15}, {23-dec-25, va, 11}] => [{23-dec-25, va, 11}]`
  - name: agg_dept
    description: |
        Sélection des valeurs et calculs des aggrégation pour le niveau DEPT en fonction des paramètres. Règles:

        - on ne garde les valeurs saisies, que si elles comportent `user_input` dans leur paramètrage (`vi_dept_from`, `va_dept_from`, `vc_dept_from`)
        - aucun calcul d'aggrégation n'est fait à ce niveau car le DEPT est la maille la plus basse
  - name: zone_parent
    description: |
        Pour chaque zone, on indique ses zones parents.

        Par exemple, pour les DEPT, on a leur REG de rattachement. Cette table est utile pour les aggrégations géographiques.  
  - name: zone_parent_parent
    description: |
        Pour chaque zone, on indique ses zones parents sur 2 niveaux.

        Par exemple, pour les DEPT, on a leur REG de rattachement et leur NAT de rattachement. Cette table est utile pour les aggrégations géographiques.
  - name: agg_reg
    description: |
        Sélection des valeurs et calculs des aggrégation pour le niveau REG en fonction des paramètres. Règles:

        - on ne garde les valeurs saisies, que si elles comportent `user_input` dans leur paramètrage (`vi_reg_from`, `va_reg_from`, `vc_reg_from`)
        - pour l'aggrégation, on ne prend en compte que les opérations `sum` et `avg`
        - les aggrégations se font de DEPT vers REG, lorsque l'on a `DEPT` dans `vi_reg_from`, `va_reg_from` ou `vc_reg_from`
        - les aggrégations se font par `metric_date` exact (pas arrondi au mois). Ex: si on a `{D75,2023-08-31,10}` et `{D91,2023-08-15,25}`, on aura `{R11,2023-08-31,10}` et `{R11,2023-08-15,25}`
        - si l'opération n'est pas supportée, on aura la valeur `-1.212121` qui sera retournée comme résultat de l'aggrégation
  - name: agg_nat
    description: |
        Sélection des valeurs et calculs des aggrégation pour le niveau NAT en fonction des paramètres. Règles:

        - on ne garde les valeurs saisies, que si elles comportent `user_input` dans leur paramètrage (`vi_nat_from`, `va_nat_from`, `vc_nat_from`)
        - pour l'aggrégation, on ne prend en compte que les opérations `sum` et `avg`
        - les aggrégations se font de REG vers NAT, lorsque l'on a `REG` dans `vi_nat_from`, `va_nat_from` ou `vc_nat_from`
        - on se base sur la table d'aggrégation de DEPT vers REG (`agg_reg`) pour déterminer les valeurs au NAT. En effet, il est possible que des valeurs DEPT soient nécessaire pour le calcul des valeurs au REG, **et** que ces valeurs calculées au REG soient nécessaires pour le calcul des valeurs NAT. Il ne faut donc pas repartir de la table des valeurs importées, mais bien de la table de résultat de l'aggrégation REG.
        - les aggrégations se font par `metric_date` exact (pas arrondi au mois). Ex: si on a `{R01,2023-08-31,10}` et `{R02,2023-08-15,25}`, on aura `{FRANCE,2023-08-31,10}` et `{FRANCE,2023-08-15,25}`
        - si l'opération n'est pas supportée, on aura la valeur `-1.212121` qui sera retournée comme résultat de l'aggrégation
  - name: agg_all
    description: "Combinaision des tables d'aggrégation aux trois mailles (DEPT, REG, NAT)"
  - name: pivot_mesures
    description: "La table des mesures aggrégées (`agg_all`) est pivotée."
  - name: get_vca
    description: |
        Réalise les calculs pour déterminer la *VCA* (ie *Valeur Cible annuelle*). Règles:

        - Pour chaque [indicateur, zone, année] il s'agit de la VC ayant la `metric_date` la plus tardive dans l'année.
  - name: get_vcg
    description: |
        Réalise les calculs pour déterminer la *VCG* (ie *Valeur Cible globale*). Règles:

        - Pour chaque [indicateur, zone] il s'agit de la VC ayant la `metric_date` la plus tardive saisie
        - **Attention**, il existe une **date maximum** dans le projet dbt, et qui assure qu'aucune VCG ne sera plus tardive que celle-ci. Sa valeur est **{{ var('vcg_max_date') }}**
  - name: get_vig
    description: |
        Réalise les calculs pour déterminer la *VIG* (ie *Valeur Initiale globale*). Règles:

        - Pour chaque [indicateur, zone] il s'agit de la VI ayant la `metric_date` la plus lointaine dans le passé.
        - **Attention**, il existe une **date minimale** dans le projet dbt, et qui assure qu'aucune VIG ne sera antérieure celle-ci. Sa valeur est **{{ var('vig_min_date') }}**

        Règles **supprimées**:
        - Si aucune VI n'est détectée, on prend la première VA. Cette première VA doit également satisfaire le critère suivant sur la *date_minimale* (cf `commit/a864d5eb18acdb478488a5aded4cb5c0ff942266`)
  - name: compute_vaca
    description: |
        Calcule les VACA (*Valeur Actuelle comparable annuelle*) pour chaque mesure. Cette valeur est celle qui sera comparée à la VC pour le calcul du TA. Règles:

        - Avant d'effectuer le calcul de la VACA, on peut **décumuler les valeurs de VA** depuis le début de l'année `from_year_start` ou depuis une date arbitraire `X` avec `from_custom_date::X`
        - Le calcul de la VACA se fait avec:
          - les opérations `sum`, `moy` ou `current_value` pour la *somme*, la *moyenne* ou utiliser simplement la valeur actuelle
          - depuis un nombre de mois donné `from_previous_month::X`, avec `X` dans `{3,6,12,48}` mois
          - depuis le début de l'année `from_year_start`
          - depuis le une date arbitraire  `X` avec `from_custom_date::X`
  - name: compute_vacg
    description: |
        Calcule les VACG (*Valeur Actuelle comparable globale*) pour chaque mesure. Cette valeur est celle qui sera comparée à la VC pour le calcul du TA. Règles:

        - Les règles sont identiques à celles de `compute_vacg` mais en prenant en compte les paramètres globaux et non annuels
  - name: merge_computed_values
    description: Jointure des VACA, VACG, VCA, VCG, VIG dans une table unqie avant de calculer les TA.
  - name: compute_ta_indic
    description: |
        Calcule les *TAA* et *TAG* (*Taux d'avancement annuels et globaux*) indicateur pour chaque mesure. Règles:

        - Les formules utilisées sont `(vacg-vig)/(vcg-vig)` pour le TAG et `100*(vaca-vig)/(vca-vig)` pour le TAA
        - Si `vig=vca` alors le TAA vaut `NULL`
        - Si `vig=vcg` alors le TAG vaut `NULL`
        - Les TA sont paramétrés pour renvoyer **{{ var('ta_decimales') }} décimales** (paramètres global dbt `ta_decimales`)
  - name: df3_indicateur
    description: |
      Table des indicateurs construite par la datafactory dbt. Version reconstruite de zero. Règles:

      - La liste des **indicateurs** provient de ref('metadata_indicateurs') 
      - La liste des **zones** provient de `public.territoire`. Donc si l'on veut renvoyer des données pour d'autres zones (académies, façades maritimes, monde, ...), il faut leur créer un territoire correspondant.
    config:
      docs:
        node_color: "#cd7f32"
      schema: public
      tags: ["df3"]